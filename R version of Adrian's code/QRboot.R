QRboot <- function(X, y, H, includeLagY = 0, QQ = seq(0.05, 0.95, by = 0.05), 
                   nDrawsBoot = 0, nLagsBootVAR = 4) {
 # QRboot: quantile regression with optional bootstrapped confidence bands.
 #    % 
 #    % Description: QRboot carries out the quantile regression of (averaged 
 #                                                                  % values of) y on X for the requested forecasting horizons and quantiles.
 #    % More specifically, for a given forecasting horizon h > 0:
 #      %   - The dependent variable in the quantile regressions is given by
 #    %     yh(t+h) = (y(t+1) + ... + y(t+h)) / h, the average value of y over
 #    %     the periods t+1,...,t+h
 #    %   - The conditioning variables are given by X(t,:); optionally, the
 #    %     current value of y can be included as conditioning variables if
 #    %     specified in the optional arguments.
 #    % The quantile regressions are estimated for all of the quantiles listed in
 #    % QQ.
 #    %
 #    % Optionally, a bootstrap sample for the quantile regression coefficients
 #    % will be generated by fitting a vector autoregression (VAR) for the
 #    % variables in both y and X, generating samples of equal length to the
 #    % original sample by using the estimated VAR parameters, and re-estimating
 #    % each quantile regression using the generated sample.
 #    % 
 #    % Input arguments:
 #      % - X : Matrix containing the conditioning variables. A column of ones will
 #    %       automatically be added to X, so that an intercept term is always
 #    %       included in regressions. If an empty matrix is provided, the
 #    %       unconditional quantiles of y will be computed. NOTE: lags of the
 #    %       dependent variable should not be included in X; rather, this should
 #    %       be specified using the includeLagY argument.
 #    % - y : Vector containing the variable to be forecasted, with length equal
 #    %       to the number of rows in X. For a given forecasting horizon h > 0,
 #    %       the value of the dependent variable at time t in each regression is
 #    %       the average value of y over the next h periods.
 #    % - H : Vector of positive integers indicating the forecasting horizons at
 #    %       which the quantile regressions will be estimated.
 #    % - includeLagY : Integer; if == 1 then the current value of y will be
 #    %                 included in the quantile regressions. Defaults to 0 
 #    %                 (current value of y not included in quantile regression).
 #    % - QQ : Vector of numbers between 0 and 1 indicating all of the quantiles
 #    %        for which the quantile regression should be estimated. Defaults to
 #    %        0.05:0.05:0.95
 #    % - nDrawsBoot : Number of bootstrapped samples to generate. If not
 #    %                specified or if set == 0, bootstrapping procedure will be
 #    %                skipped. Defaults to 0.
 #    % - nlagsBootVAR : Number of lags to include in the VAR fit to y and X that
 #    %                  will be used to generate bootstrapped samples. Defaults 
 #    %                  to 4.
 #    %
 #    % Output arguments:
 #      % - Res : struct containing the following fields (for convenience let T
 #                                                        %         denote the number of rows of X and let k denote the number of
 #                                                        %         conditioning variables included in each regression, including the
 #                                                        %         intercept and lagged dependent variable values)
 #    %   - BQ : Array with dimensions (k, length(QQ), max(H)) such that
 #    %          BQ(:, jq, h) contains the estimated quantile regression
 #    %          coefficients for the jqth quantile and forecasting horizon h.
 #    %   - YQ : Array with dimensions (T, length(QQ), max(H)) such that
 #    %          YQ(t, jq, h) contains the fitted conditional jqth quantile for
 #    %          y(t).
 #    %   - B2 : Array with dimensions (k, max(H)) such that B2(:, h) contains
 #    %          the estimated OLS coefficients for forecasting horizon h.
 #    %   - Y2 : Array with dimensions (k, max(H)) such that Y2(t, h) contains
 #    %          the OLS fitted value for y(t).
 #    %   - bBQ : If nDrawsBoot > 0, array with dimensions
 #    %           (k, length(QQ), max(H), nDrawsBoot) such that bBQ(:, jq, h, n)
 #    %           contains the estimated quantile regression coefficients for the
 #    %           jqth quantile and forecasting horizon h, estimated from the nth
 #    %           bootstrapped sample.
 #    %   - bB2 : If nDrawsBoot > 0, array with dimensions
 #    %           (T, max(H), nDrawsBoot) such that bBQ(t, h, n) contains the
 #    %           estimated OLS coefficients for forecasting horizon h, estimated
 #    %           from the nth bootstrapped sample.
 #    %
 #    % NOTE: if the integers in H are not consecutive, then the entries in Res
 #    % corresponding to the forecasting horizons not included in h will be
 #    % filled with zeros, i.e. if H = [1,4] then Res.BQ(:,:,2:3) will consist of
 #    % zeros.}
  
  
  #X <- X[, 2] #Poi elimino sta riga
  #includeLagY = 1 #Poi elimino sta riga
  #nDrawsBoot <- 1000
  
  
  
  
  X <-as.matrix(X)
  # Check if X is an empty matrix
  if (ncol(X) == 0 && nrow(X) == 0) {
    Z <- matrix(1, nrow=length(y), ncol=1)  # Just a column of ones
  } else {
    Z <- cbind(1, X)  # add intercept column
  }

  if (includeLagY == 1) {
    Z <- cbind(Z, y)
  }
  
  Z <-as.matrix(Z)
  
  # Construct the matrix Yh containing h-period averages of y
  max_h <- max(H)
  T <- length(y)
  Yh <- matrix(NA, T, max_h)
  
  #------------------ Fin qui è corretto
  
  # % Create matrix Yh where Yh(t+h,h) = (y(t+1) + ... + y(t+h)) / h,
  # % i.e. Yh(t+h,h) is the average value of y from t+1 to t+h.
  
    for(h in H) {
      Yh[, h] <- stats::filter(y, rep(1/h, h), sides=1)
      Yh[1:(h - 1), h] <- NA
    }
  
  
  # Initialize containers for the results
  k <- ncol(Z) 
  BQ <- array(0, dim = c(k, length(QQ), max_h))
  YQ <- array(0, dim = c(T, length(QQ), max_h))
  B2 <- matrix(0, nrow = k, ncol = max_h)
  Y2 <- matrix(0, nrow = T, ncol = max_h)
  
  # Implement quantile (and OLS) regression for each horizon/quantile pair
  for (h in H) {
    yh <- Yh[(h + 1):T, h]
    Zh <- as.matrix(Z[1:(T - h), ])

    # OLS regression
    B2[,h] <- coef(lm(yh ~ Zh - 1))
    Y2[(h + 1):T, h] <- Zh %*% B2[, h]
    Y2[1:h, h] <- NA   # Set the first 'h' values to NA
    
    # Quantile regressions
    for (jq in 1:length(QQ)) {
      BQ[,jq,h] <- rq.fit(Zh, yh, tau = QQ[jq])$coef
      YQ[(h + 1):T, jq, h] <- Zh %*% BQ[,jq,h]
      YQ[1:h, jq, h] <- NA  # Set the first 'h' values to NA
    }
  }
  
  
  
  #------------------ Fin qui è giusto! Non ho controllato ogni variabile, ma quelle controllate sono uguali
  
  
  # Implement the bootstrap procedure
  if (nDrawsBoot > 0) {
    DataBoot <- VARsimul(cbind(y,X), nLagsBootVAR, nDrawsBoot)   #cbind(y,X) is a 172x2 matrix
    
    #DataBoot is 172x2x1000
    
    bBQ <- array(0, dim = c(k, length(QQ), max_h, nDrawsBoot))  # 3 x 19 x 4 x 1000
    bB2 <- array(0, dim = c(k, max_h, nDrawsBoot))  # 3 x 4 x 1000
    
    for (jm in 1:nDrawsBoot) { #da 1 a 1000
      y_boot <- DataBoot[,1,jm] #172x1x1
      X_boot <- DataBoot[, -1, jm] #172x1x1
      
      Z <- cbind(1, X_boot)
      if (includeLagY == 1) {
        Z <- cbind(Z, y_boot) #172x3
      }
      print(length(filter(y_boot, rep(1/h, h), sides = 1)))
      
      Yh_boot <- matrix(NA, T, max_h) # 172x4
      for (h in H) {
        Yh_boot[, h] <- stats::filter(y_boot, rep(1/h, h), sides=1)
        Yh_boot[1:(h - 1), h] <- NA
      }
      
      for (h in H) {
        yh <- Yh_boot[(h + 1):T, h]
        Zh <- Z[1:(T - h), ]
        
        # OLS regression
        bB2[, h,jm] <- coef(lm(yh ~ Zh - 1))
        
        # Quantile regressions
        for (jq in 1:length(QQ)) {
          bBQ[, jq, h, jm] <- rq.fit(Zh, yh, tau = QQ[jq])$coef
        }
      }
    }
    
    Res <- list(BQ = BQ, YQ = YQ, B2 = B2, Y2 = Y2, bBQ = bBQ, bB2 = bB2, QQ = QQ)
  } else {
    Res <- list(BQ = BQ, YQ = YQ, B2 = B2, Y2 = Y2, QQ = QQ)
  }
  
  return(Res)
}





VARsimul <- function(X, p, nSim) {
  # %% VARsimul: fit VAR to data and generate samples of equal length
  # %
  # % Description: VARsimul fits a VAR with p lags to the provided data X and
  # % uses the estimated parameters to simulate samples of equal length (using
  #                                                                      % the same p initial values contained in X and Gaussian shocks with
  #                                                                      % covariance matrix estimated from the data).
  # % 
  # % Input arguments:
  #   % - X : T-by-N matrix containing data used to estimate the VAR parameters.
  # % - p : Number of lags to include in the estimated VAR.
  # % - nSim : Number of samples to generate using the estimated parameters.
  # %
  # % Output arguments:
  #   % - XXb : T-by-N-by-nSim array, such that XXb(:,:,m) contains a simulated
  # %         sample.
  # 
  # Estimate VAR parameters using data provided in X
  T <- nrow(X)    #172
  N <- ncol(X)    #2

  
  # Construct Z matrix of right-hand side variables (constant plus lags of X)
  Z <- matrix(1, nrow=T-p, ncol=1) #168x1 matrix, full of 1
  for(j in 1:p) {
    Z <- cbind(Z, X[(p + 2 - j):(T + 1 - j), ])
  }
  
  cat("Dimensions of Z:", dim(Z), "\n")  #168x9, correct
  
  y <- X[(p + 1):T, ]  #168x2
  
  cat("Dimensions of y:", dim(y), "\n")  #168x2, correct
  
  
  # Estimate VAR coefficient matrix and innovation covariance matrix
  beta <- solve(t(Z) %*% Z) %*% t(Z) %*% y
  
  cat("Dimensions of beta:", dim(beta), "\n")  #9x2, correct
  
  resid <- y - Z %*% beta
  Sigma <- cov(resid)
  
  # Simulate samples
  XXb <- array(0, dim=c(T, N, nSim))  #172x 2 x 1000


  for(m in 1:nSim) {   #da 1 a 1000
    Xb <- matrix(0, nrow=T, ncol=N)   #Xb creata come una matrice 172x2, come X ma piena di 0
    Xb[1:p, ] <- X[1:p, ]   #ora prendo le prime 4 righe di Xb e le rendo uguali a X
    err <- matrix(rnorm(T*N), ncol=N) %*% chol(Sigma)
    
    for(t in (p + 1):T) {
      # Construct Zt matrix of time t values for conditioning variables
      Zt <- matrix(1, nrow = 1, ncol = 1)
      for(j in 1:p) {
        Zt <- cbind(Zt, Xb[t - j, , drop = FALSE])
        cat("Dimensions of Zt:", dim(Zt), "\n")
        
      }
      

      Xb[t, ] <- Zt %*% beta + err[t, ]
    }
    XXb[, , m] <- Xb
  }
  print(dim(XXb))
  
  return(XXb)
}
  
  


  

